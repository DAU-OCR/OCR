# OCR 프로젝트 종합 보고서

이 문서는 차량 번호판 OCR 프로젝트의 초기 목표 설정부터 최종 빌드 및 배포에 이르기까지의 전 과정을 기록하고, 그 과정에서 발생한 주요 기술적 문제들과 해결 과정을 상세히 기술한 종합 보고서입니다.

---

## 1. 프로젝트 개요

### 1.1. 목표
- **핵심 기능**: 차량 번호판 이미지를 입력받아 텍스트를 인식(OCR)하고, 결과를 관리하는 애플리케이션 개발.
- **사용자 기능**:
    - 인식된 결과를 JSON/Excel 파일로 다운로드.
    - 결과 테이블에서 키보드를 이용한 편리한 탐색 및 수정.
- **최종 목표**: 프론트엔드(React/Electron)와 백엔드(Python/Flask)를 하나의 설치 가능한 실행 파일(`.exe`)로 패키징하여 간편하게 배포.

### 1.2. 기술 스택 및 아키텍처
- **프론트엔드**: React.js, Electron (데스크톱 앱 패키징)
- **백엔드**: Python, Flask (API 서버), PyInstaller (서버 실행 파일 빌드)
- **OCR 모델**: YOLOv5 (번호판 탐지), EasyOCR, CRNN (문자 인식)

---

## 2. 최종 결과 및 실행 방법

### 2.1. 최종 상태
- **분리 실행 방식 채택**: 초기 목표였던 단일 실행 파일 통합은, Electron 자식 프로세스로 실행되는 Python 서버에서 발생하는 네이티브 라이브러리 충돌(`forrtl: error (200)`) 문제로 인해 보류되었습니다. 이 문제는 코드 레벨에서 원격으로 해결하기 어려운 깊은 수준의 환경 의존적 문제로 판단되었습니다.
- **결과**: 프론트엔드(`ocr-web.exe`)와 백엔드(`ocr_server.exe`)가 각각 독립적으로 완벽하게 동작하는 **두 개의 실행 파일로 최종 결과물이 완성**되었습니다. 사용자는 두 프로그램을 개별적으로 실행하여 전체 서비스를 이용할 수 있습니다.

### 2.2. 실행 가이드
1.  **백엔드 서버 실행**: `ocr_server.exe` 파일을 실행하여 API 서버를 시작합니다.
2.  **프론트엔드 앱 실행**: `ocr-web.exe` 파일을 실행하여 사용자 인터페이스를 엽니다.
3.  이후 앱 내에서 이미지 업로드, 결과 확인, 다운로드 등 모든 기능을 정상적으로 사용할 수 있습니다.

---

## 3. 핵심 개발 과정 및 문제 해결

### 3.1. 백엔드 (Python OCR 서버)

#### 3.1.1. PyInstaller 빌드 안정화 과정
- **초기 문제**: `PyInstaller`로 서버를 `.exe` 파일로 빌드 시, 복잡한 라이브러리(torch, opencv 등) 의존성으로 인해 `ModuleNotFoundError`, `AttributeError` 등 다양한 런타임 오류 발생.
- **원인 분석**:
    1.  **의존성 지옥(Dependency Hell)**: 프로젝트에 불필요한 `torchaudio`, `craft-text-detector` 등의 라이브러리가 다른 핵심 라이브러리와 버전 충돌을 일으킴.
    2.  **PyInstaller의 패키징 누락**: `PyInstaller`의 정적 분석기가 `numpy`, `torch`, `ultralytics` 등의 하위 모듈 및 데이터 파일을 완벽하게 탐지하지 못하고 빌드에서 누락시킴.
- **해결 과정**:
    1.  **라이브러리 환경 정리**: 불필요한 패키지를 모두 제거하고, `torch==2.3.0+cpu`, `numpy==1.26.4` 등 핵심 라이브러리들의 호환되는 버전을 명시하여 깨끗한 환경을 재구성.
    2.  **`.spec` 파일 대폭 수정**: `hiddenimports`만으로는 부족하여, `PyInstaller.utils.hooks.collect_all` 함수를 사용. 문제가 발생한 모든 라이브러리(`numpy`, `torch`, `cv2`, `ultralytics` 등)의 코드, 데이터, 바이너리를 강제로 수집하여 빌드에 포함하도록 `ocr_server_patched.spec` 파일을 수정.

#### 3.1.2. 런타임 오류 디버깅
- **`AttributeError` (YOLOv5 AutoShape)**: 빌드된 환경에서 YOLOv5의 `AutoShape` 기능이 비정상 동작. 이미지 전처리 및 후처리(NMS)를 수동으로 구현하여 해결.
- **CUDA 및 디바이스 관련 오류**:
    - `AttributeError: 'NoneType' object has no attribute 'write'`: `torch.hub.load`의 `force_reload=True` 옵션이 PyInstaller 환경과 충돌. 해당 옵션 제거.
    - `RuntimeError: Expected all tensors to be on the same device...`: `os.environ['CUDA_VISIBLE_DEVICES'] = ''` 코드를 추가하여 GPU 사용을 비활성화하고 CPU만 사용하도록 강제.
    - `AssertionError: Invalid device id`: YOLOv5 모델 로딩 시 `device='cpu'`를 명시적으로 지정하여 해결.
- **`_pickle.UnpicklingError`**: 최신 PyTorch의 보안 정책 변경으로 인한 모델 로딩 실패. `weights_only=False` 옵션을 추가하여 해결.

#### 3.1.3. OCR 성능 및 기능 개선
- **결과 선택 로직 개선**: 초기에는 신뢰도(confidence)가 가장 높은 결과를 선택했으나, CRNN 모델의 점수가 높게 나오는 경향이 있어 정확도가 떨어짐. 아래와 같은 하이브리드 로직으로 개선:
    1.  **다수결 원칙**: 3개 모델 중 2개 이상이 동일한 결과를 내면 최우선 채택.
    2.  **모델1(EasyOCR-ko) 우선 원칙**: 다수결이 없으면, 모델1의 결과가 유효할 경우 채택.
    3.  **가중치 비교**: 위 두 조건에 해당하지 않으면, CRNN 모델 신뢰도에 0.9 페널티를 적용 후 가장 높은 점수의 결과를 채택.
- **엑셀 저장 시 이미지 회전 문제**: 이미지의 EXIF 메타데이터 때문에 엑셀 저장 시 사진이 회전되는 문제 발생. `Pillow`의 `ImageOps.exif_transpose` 기능을 적용하여 이미지 방향을 자동으로 보정.

### 3.2. 프론트엔드 (React Electron 앱)

#### 3.2.1. Electron 빌드 및 패키징
- **백엔드 실행 파일 포함 문제**: `electron-builder`가 `ocr_server.exe`를 최종 패키지에 포함시키지 못함. `package.json`의 `extraFiles` 설정을 수정하여 빌드 시 백엔드 파일이 안정적으로 복사되도록 조치.
- **`electron.cjs` 경로 문제**: 패키징된 앱에서 `ocr_server.exe`를 찾는 경로 로직이 잘못되어 앱 실행 실패. `app.isPackaged`로 개발/프로덕션 환경을 구분하여 각 환경에 맞는 올바른 경로를 찾도록 `electron.cjs` 파일 전체를 재작성.
- **`makensis.exe` 빌드 실패**: `electron-builder`가 NSIS 설치 프로그램을 생성하는 과정에서 메모리 매핑 오류 발생. `win.target`을 `["zip"]`으로 변경하여 NSIS 과정을 우회하고, 압축 파일 형태의 무설치(portable) 버전으로 성공적으로 빌드.

#### 3.2.2. 패키징 후 런타임 오류 디버깅
- **흰 화면 및 리소스 로드 실패 (`net::ERR_FILE_NOT_FOUND`)**:
    - **원인**: `vite.config.js`의 `base` 설정이 없어 리소스 경로가 절대 경로(`/`)로 빌드됨. Electron의 `file://` 프로토콜에서는 상대 경로(`./`)가 필요.
    - **해결**: `vite.config.js`에 `base: './'` 설정을 추가.
- **React Router 경로 오류**:
    - **원인**: 웹서버용 `BrowserRouter`가 `file://` 환경과 호환되지 않음.
    - **해결**: 라우터를 Electron 환경에 적합한 `HashRouter`로 변경.
- **API 요청 및 이미지 로드 실패**:
    - **원인**: 빌드된 앱에서 API 요청이 백엔드(`http://localhost:5000`)가 아닌 로컬 파일 경로로 잘못 전송됨.
    - **해결**: 모든 API 요청(axios) 및 동적 이미지 경로에 `http://localhost:5000` 전체 URL을 명시적으로 추가.

#### 3.2.3. 사용자 경험(UX) 개선
- **백엔드 CMD 창 숨기기**: `electron.cjs`에서 서버 실행 시 `windowsHide: true` 옵션을 추가하여, 백그라운드에서 조용히 실행되도록 수정.
- **팝업 내 키보드 탐색**: 결과 이미지 상세 팝업에서 키보드 방향키(↑, ↓)로 이전/다음 이미지를 탐색하는 기능을 추가.
- **프로세스 종료 문제**: 앱 종료 시 `ocr_server.exe` 프로세스가 좀비처럼 남아있는 문제. `taskkill` 명령어를 `will-quit` 이벤트에 추가하여 앱 종료 시 관련 프로세스를 강제 종료하도록 수정.

---

## 4. 부록: CRNN 모델 학습 및 개선 과정

프로젝트의 핵심인 CRNN 모델의 성능을 높이기 위해, 학습 실패 원인을 진단하고 해결하는 체계적인 과정을 거쳤습니다.

- **초기 문제**: 검증(Validation) 정확도는 94%로 높으나, 실제 데이터 테스트 시 63%로 급락하는 과적합(Overfitting) 문제 발생.

- **해결 전략**: "Data-Centric Improvement" 접근법 채택. 모델 구조 변경보다 데이터의 질을 개선하는 데 집중.

- **학습 실패 원인 분석 및 해결 과정 (가설 검증)**:
    1.  **가설 1: 데이터셋 결함 → 기각**
        - **검증**: `verify_dataset.py` 스크립트로 이미지/라벨 파일의 개수, 매칭, 손상 여부를 검증. 데이터셋 자체는 문제가 없음을 확인.
    2.  **가설 2: 모델 표현력 부족 → 검증 및 해결**
        - **현상**: 256개의 복잡한 한글/영문/숫자 클래스를 `hidden_size=256`인 모델이 학습하지 못함.
        - **검증**: 문자셋을 '초성+중성+숫자' (36개)로 줄인 '미니 데이터셋'으로도 학습에 실패.
        - **해결**: `hidden_size`를 `512`로 늘리고, 학습률 스케줄러를 수동적인 `ReduceLROnPlateau`에서 능동적인 `OneCycleLR`로 변경. '미니 데이터셋'에서 **정확도 96.39%**를 달성하며 가설 입증.
    3.  **가설 3: 불완전한 문자셋 → 검증 및 해결**
        - **현상**: `hidden_size=512` 모델로도 전체 데이터셋 학습 시 정확도가 31%에서 정체.
        - **원인**: 학습에 사용된 문자셋(`VIRTUAL_CHARSET`)에 **한글 자음/모음(자모)이 누락**되어 있었음을 발견.
        - **해결**: `JAMO_CHARS`를 `VIRTUAL_CHARSET`에 추가하여 완전한 문자셋을 구축.
    4.  **가설 4: 데이터 불균형 → 기각**
        - **검증**: `analyze_dataset.py`로 전체 데이터셋의 문자별 분포를 분석. 모든 문자가 정확히 500개씩 존재하는 **완벽하게 균형 잡힌 데이터셋**임을 확인.
    5.  **가설 5: 문자셋 간 간섭 현상 → 최종 가설**
        - **현상**: 완전한 문자셋으로도 정확도가 42%에서 정체.
        - **가설**: 'B'와 '비', '0'과 'ㅇ'처럼 시각적으로 유사한 다른 언어의 문자들을 동시에 학습하며 모델이 혼란을 겪는 **"간섭 현상"**이 발생.
        - **해결 시도**: 간섭 요인(영문)을 제거한 '한글 전용 데이터셋'을 생성하여 학습을 시도.
    6.  **가설 6: 부적절한 학습률 → 해결**
        - **현상**: '한글 전용 데이터셋' 학습 시 손실(loss) 값이 줄어들지 않는 정체 현상 발생.
        - **원인**: 학습률(`max_lr=0.001`)이 너무 높아 최적점을 찾지 못하는 것으로 판단.
        - **해결**: `max_lr`을 `0.0001`로 낮추어 안정적인 학습을 유도.

이러한 체계적인 가설 설정과 검증을 통해, 복잡한 모델 학습 문제를 단계적으로 해결하고 모델의 잠재 성능을 끌어올릴 수 있는 기반을 마련했습니다.
